#!/usr/bin/env python
# vim: tabstop=4 shiftwidth=4 softtabstop=4
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.

"""
Tools to generate JEOS TDLs, build the images and register them in Glance.
"""

import base64
import ConfigParser
import gettext
from glob import glob
import inspect
import json
import logging
from lxml import etree
import optparse
import os
import os.path
import re
import sys
import textwrap
import time
import traceback


from glance.common import exception
from glance import client as glance_client
import oz.TDL
import oz.GuestFactory
from prettytable import PrettyTable


possible_topdir = os.path.normpath(os.path.join(os.path.abspath(sys.argv[0]),
                                   os.pardir,
                                   os.pardir))

if os.path.exists(os.path.join(possible_topdir, 'heat_jeos')):
    sys.path.insert(0, possible_topdir)

import heat_jeos
jeos_module_path = os.path.abspath(os.path.dirname(heat_jeos.__file__))


def command_list(options, arguments):
    """
    List all available templates.
    """
    templates = sorted(glob('%s/*.tdl' % options.jeos_dir))
    table = PrettyTable(['Name', 'OS', 'Version', 'Architecture'])
    try:  # prettytable version 0.5 -- on Fedora 16 and 17
        table.set_field_align('Name', 'l')
    except AttributeError:  # prettytable version 0.6  -- on Ubuntu 12.04
        table.align['Name'] = 'l'
    for template_path in templates:
        table.add_row(template_metadata(template_path))
    print table


register_with_glance_message = """
Now register with Glance using:

glance add name=%s is_public=true disk_format=qcow2 container_format=ovf < %s
"""


def command_create(options, arguments):
    """
    Create a new JEOS (Just Enough Operating System) image and (optionally)
    register it.

    Usage:
    heat-jeos create (<name> | --template-file=FILE) <options>

    Arguments:
    name                    Template name from `heat-jeos list`
    --template-file=FILE    Path to the template file to use
    --gold                  Build a basic gold JEOS (without cfntools)
    --iso=FILE              Path to the ISO file to use as the base OS image
    --register-with-glance  Register the image with Glance after it's built

    The command must be run as root in order for libvirt to have permissions
    to create virtual machines and read the raw DVDs.

    The image ISO must be specified in the Template file under the
    `/template/os/install/iso` section or passed using the `--iso` argument.
    """
    tdl_path = None
    if len(arguments) == 0:
        tdl_path = options.template_file
    elif len(arguments) == 1:
        tdl_path = find_template_by_name(options.jeos_dir, arguments[0])

    if not tdl_path:
        print 'You must specify a correct template name or path.'
        sys.exit(1)

    if os.geteuid() != 0:
        logging.error("This command must be run as root")
        sys.exit(1)

    if options.register_with_glance:
        client = get_glance_client(options)
        try:
            client.get_image('test')
        except exception.NotFound:
            pass
        except Exception:
            print("Cannot connect to Glance. Please verify that it's running "
                  "and check your credentials.")
            sys.exit(1)

    instance_type = 'gold' if options.gold else 'cfntools'

    oz_guest = get_oz_guest(tdl_path)
    dsk_path, qcow2_path, image_name = target_image_paths(oz_guest)

    should_build_jeos = True
    if os.access(qcow2_path, os.R_OK):
        should_build_jeos = options.yes or prompt_bool('An existing JEOS was '
            'found on disk. Do you want to build a fresh JEOS? (y/n) ')

    if should_build_jeos:
        final_tdl = '/tmp/tdl'
        create_tdl(tdl_path, instance_type, options.iso, options.cfn_dir,
                   final_tdl)

        logging.info('Creating JEOS image (%s) - '
                     'this takes approximately 10 minutes.' % image_name)
        build_jeos(get_oz_guest(final_tdl))
        print('\nGenerated image: %s' % qcow2_path)

        if not options.register_with_glance:
            print(register_with_glance_message % (image_name, qcow2_path))
            return

    if not options.register_with_glance:
        return

    logging.info('Registering JEOS image (%s) with OpenStack Glance.' %
                 image_name)
    if not os.access(qcow2_path, os.R_OK):
        logging.error('Cannot find image %s.' % qcow2_path)
        sys.exit(1)

    try:
        client = get_glance_client(options)
        image = find_image(client, image_name)
        if image:
            delete_image = options.yes or prompt_bool('Do you want to '
                    'delete the existing JEOS in glance? (y/n) ')
            if delete_image:
                client.delete_image(image['id'])
            else:
                logging.info('No action taken')
                sys.exit(0)
        image_id = register_image(client, qcow2_path, image_name,
                                  options.username, image)
        print('\nImage %s was registered with ID %s' % (image_name, image_id))
    except exception.ClientConnectionError, e:
        logging.error('Failed to connect to the Glance API server.')
        sys.exit(1)
    except Exception, e:
        logging.error(" Failed to add image. Got error:")
        traceback.print_exc()
        logging.warning("Note: Your image metadata may still be in the "
               "registry, but the image's status will likely be 'killed'.")
        sys.exit(1)


def get_glance_client(options):
    """
    Returns a new Glance client connection based on the passed options.
    """
    creds = dict(username=options.username,
                 password=options.password,
                 tenant=options.tenant,
                 auth_url=options.auth_url,
                 strategy=options.auth_strategy)

    # When neither host nor port are specified and we're using Keystone auth,
    # let it tell us the Glance entrypoint
    configure_via_auth = (options.auth_strategy == 'keystone' and
                          not (options.glance_host or options.glance_port))

    # NOTE: these are ignored by the client when `configure_via_auth` is True
    glance_host = options.glance_host if options.glance_host else '0.0.0.0'
    try:
        glance_port = int(options.glance_port) if options.glance_port else 9292
    except:
        logging.error('Port must be a number.')
        sys.exit(1)

    if configure_via_auth:
        logging.debug('Using Glance entry point received by Keystone.')
    else:
        logging.debug('Connecting to Glance at host: %s, port: %d' %
                      (glance_host, glance_port))

    client = glance_client.Client(host=glance_host,
                                  port=glance_port,
                                  use_ssl=False,
                                  auth_tok=None,
                                  configure_via_auth=configure_via_auth,
                                  creds=creds)
    return client


def find_image(client, image_name):
    """
    Looks up the image of a given name in Glance.

    Returns the image metadata or None if no image is found.
    """
    parameters = {
        "filters": {},
        "limit": 10,
    }

    images = client.get_images(**parameters)

    try:
        image = [i for i in images if i['name'] == image_name][0]
    except IndexError:
        image = None
    return image


def template_metadata(template_path):
    """
    Parse the given TDL and return its metadata (name, arch, distro, version).
    """
    tdl = etree.parse(template_path)
    name = tdl.findtext('name', default='n/a')
    distro = tdl.findtext('os/name', default='n/a')
    architecture = tdl.findtext('os/arch', default='n/a')
    version = tdl.findtext('os/version', default='n/a')
    return [name, distro, version, architecture]


def find_template_by_name(template_dir, template_name):
    """
    Look through the templates in the given directory, find the one with
    matching name and return its path.

    Return `None` otherwise.
    """
    for template_path in glob('%s/*.tdl' % template_dir):
        name, distro, version, arch = template_metadata(template_path)
        if name == template_name:
            return template_path


def prompt_bool(question):
    """
    Ask the user a yes/no question and return the answer as a bool.
    """
    while True:
        answer = raw_input(question).lower()
        if answer in ('y', 'yes'):
            return True
        if answer in ('n', 'no'):
            return False


def ensure_xml_path(element, path):
    """
    Make sure the given path in the XML element exists. Create the elements as
    needed.
    """
    if not path:
        return
    tag = path[0]
    el = element.find(tag)
    if not el:
        el = etree.Element(tag)
        element.append(el)
    ensure_xml_path(el, path[1:])


def create_tdl(tdl_path, instance_type, iso_path, cfn_dir, output_tdl_path):
    """
    Prepare the template for use with Heat.

    If the `instance_type` is `cfntools`, include the cfn binaries.

    If the `iso_path` is specified, override the template's ISO with it.
    """
    logging.debug("Using tdl: %s" % tdl_path)

    # Load the cfntools into the cfntool image by encoding them in base64
    # and injecting them into the TDL at the appropriate place
    tdl_xml = etree.parse(tdl_path)
    if instance_type == 'cfntools':
        cfn_tools = ['cfn-init', 'cfn-hup', 'cfn-signal',
                    'cfn-get-metadata', 'cfn_helper.py', 'cfn-push-stats']
        for cfnname in cfn_tools:
            f = open('%s/%s' % (cfn_dir, cfnname), 'r')
            cfscript_e64 = base64.b64encode(f.read())
            f.close()
            cfnpath = "/template/files/file[@name='/opt/aws/bin/%s']" % cfnname
            tdl_xml.xpath(cfnpath)[0].text = cfscript_e64
    if iso_path:
        root = tdl_xml.getroot()
        ensure_xml_path(root, ['os', 'install', 'iso'])
        elem = root.find('os/install/iso')
        elem.text = 'file:%s' % iso_path

    # TODO(sdake) INSECURE
    tdl_xml.write(output_tdl_path, xml_declaration=True)


def get_oz_guest(tdl_path):
    """
    Returns Oz Guest instance based on the passed template.
    """
    tdl = oz.TDL.TDL(open(tdl_path, 'r').read())
    config_file = "/etc/oz/oz.cfg"
    config = ConfigParser.SafeConfigParser()
    if os.access(config_file, os.F_OK):
        config.read(config_file)
    return oz.GuestFactory.guest_factory(tdl, config, None, None)


def target_image_paths(oz_guest):
    """
    Return the image paths and the image name that Oz will generate.
    """
    dsk_path = oz_guest.diskimage
    qcow2_path = os.path.splitext(dsk_path)[0] + '.qcow2'
    image_name = oz_guest.name
    return dsk_path, qcow2_path, image_name

def build_jeos(guest):
    """
    Use Oz to build the JEOS image.
    """
    logging.debug("Running Oz")
    dsk_path, qcow2_path, image_name = target_image_paths(guest)
    if os.path.exists(qcow2_path):
        os.remove(qcow2_path)
    if os.path.exists(dsk_path):
        os.remove(dsk_path)

    guest.check_for_guest_conflict()
    try:
        force_download = False
        guest.generate_install_media(force_download)
        try:
            guest.generate_diskimage(force=force_download)
            libvirt_xml = guest.install(50000, force_download)
        except:
            guest.cleanup_old_guest()
            raise
    finally:
        guest.cleanup_install()

    guest.customize(libvirt_xml)

    if not os.access(dsk_path, os.R_OK):
        logging.error('oz-install did not create the image,'
                      ' check your oz installation.')
        sys.exit(1)

    logging.info('Converting raw disk image to a qcow2 image.')
    os.system("qemu-img convert -c -O qcow2 %s %s" % (dsk_path, qcow2_path))


def register_image(client, qcow2_path, name, owner, existing_image):
    """
    Register the given image with Glance.
    """
    image_meta = {'name': name,
                  'is_public': True,
                  'disk_format': 'qcow2',
                  'min_disk': 0,
                  'min_ram': 0,
                  'owner': owner,
                  'container_format': 'bare'}

    if existing_image:
        client.delete_image(existing_image['id'])

    with open(qcow2_path) as ifile:
        image_meta = client.add_image(image_meta, ifile)
    image_id = image_meta['id']
    logging.debug(" Added new image with ID: %s" % image_id)
    logging.debug(" Returned the following metadata for the new image:")
    for k, v in sorted(image_meta.items()):
        logging.debug(" %(k)30s => %(v)s" % locals())
    return image_id


def create_options(parser):
    """
    Sets up the CLI and config-file options that may be
    parsed and program commands.

    :param parser: The option parser
    """
    parser.add_option('-t', '--template-file',
                      default=None,
                      help="Path to the template file to build image from")
    parser.add_option('-j', '--jeos-dir',
                      default=os.path.join(jeos_module_path, 'jeos'),
                      help="Path to the JEOS templates directory")
    parser.add_option('-c', '--cfn-dir',
                      default=os.path.join(jeos_module_path, 'cfntools'),
                      help="Path to cfntools directory")
    parser.add_option('-v', '--verbose', default=False, action="store_true",
                      help="Print more verbose output")
    parser.add_option('-d', '--debug', default=False, action="store_true",
                      help="Print more verbose output")
    parser.add_option('-g', '--gold', default=False, action="store_true",
                      help="Build a basic gold JEOS")
    parser.add_option('-s', '--iso', default=None,
                      help="Path to the ISO file to use as the base OS image")
    parser.add_option('-G', '--register-with-glance', default=False,
                      action='store_true', help="Register the image with Glance")
    parser.add_option('-y', '--yes', default=False, action="store_true",
                      help="Don't prompt for user input; assume the answer to "
                           "every question is 'yes'.")
    parser.add_option('-H', '--glance-host',
                      default=None,
                      help="Glance hostname")
    parser.add_option('-P', '--glance-port',
                      default=None,
                      help="Glance port number")
    parser.add_option('-A', '--auth_token', dest="auth_token",
                      metavar="TOKEN", default=None,
                      help="Authentication token to use to identify the "
                           "client to the heat server")
    parser.add_option('-I', '--username', dest="username",
                      metavar="USER", default=None,
                      help="User name used to acquire an authentication token")
    parser.add_option('-K', '--password', dest="password",
                      metavar="PASSWORD", default=None,
                      help="Password used to acquire an authentication token")
    parser.add_option('-T', '--tenant', dest="tenant",
                      metavar="TENANT", default=None,
                      help="Tenant name used for Keystone authentication")
    parser.add_option('-R', '--region', dest="region",
                      metavar="REGION", default=None,
                      help="Region name. When using keystone authentication "
                      "version 2.0 or later this identifies the region "
                      "name to use when selecting the service endpoint. A "
                      "region name must be provided if more than one "
                      "region endpoint is available")
    parser.add_option('-N', '--auth_url', dest="auth_url",
                      metavar="AUTH_URL", default=None,
                      help="Authentication URL")
    parser.add_option('-S', '--auth_strategy', dest="auth_strategy",
                      metavar="STRATEGY", default=None,
                      help="Authentication strategy (keystone or noauth)")


def credentials_from_env():
    return dict(username=os.getenv('OS_USERNAME'),
                password=os.getenv('OS_PASSWORD'),
                tenant=os.getenv('OS_TENANT_NAME'),
                auth_url=os.getenv('OS_AUTH_URL'),
                auth_strategy=os.getenv('OS_AUTH_STRATEGY'))


def parse_options(parser, cli_args):
    """
    Returns the parsed CLI options, command to run and its arguments, merged
    with any same-named options found in a configuration file

    :param parser: The option parser
    """
    if not cli_args:
        cli_args.append('-h')  # Show options in usage output...

    (options, args) = parser.parse_args(cli_args)
    env_opts = credentials_from_env()
    for option, env_val in env_opts.items():
        if not getattr(options, option):
            setattr(options, option, env_val)

    if not options.auth_strategy:
        options.auth_strategy = 'noauth'

    # HACK(sirp): Make the parser available to the print_help method
    # print_help is a command, so it only accepts (options, args); we could
    # one-off have it take (parser, options, args), however, for now, I think
    # this little hack will suffice
    options.__parser = parser

    if not args:
        parser.print_usage()
        sys.exit(0)

    command_name = args.pop(0)
    command = lookup_command(parser, command_name)

    if options.debug:
        logging.basicConfig(format='%(levelname)s:%(message)s',\
            level=logging.DEBUG)
        logging.debug("Debug level logging enabled")
    elif options.verbose:
        logging.basicConfig(format='%(levelname)s:%(message)s',\
            level=logging.INFO)
    else:
        logging.basicConfig(format='%(levelname)s:%(message)s',\
            level=logging.WARNING)

    options.jeos_dir = os.path.join(os.getcwd(), options.jeos_dir)
    options.cfn_dir = os.path.join(os.getcwd(), options.cfn_dir)

    return (options, command, args)


def print_help(options, args):
    """
    Print help specific to a command
    """
    parser = options.__parser

    if not args:
        parser.print_usage()

    subst = {'prog': os.path.basename(sys.argv[0])}
    docs = [lookup_command(parser, cmd).__doc__ % subst for cmd in args]
    print '\n\n'.join(docs)


def lookup_command(parser, command_name):
    commands = {
        'list': command_list,
        'create': command_create,
        'help': print_help,
    }

    try:
        command = commands[command_name]
    except KeyError:
        parser.print_usage()
        sys.exit("Unknown command: %s" % command_name)
    return command


def main():
    '''
    '''
    usage = """
%prog <command> [options] [args]

Commands:

    list        Prepare a template ready for Oz

    create     Create a JEOS image from a template

    help <command>  Output help for one of the commands below

"""

    oparser = optparse.OptionParser(version='%%prog %s'
                                    % '0.0.1',
                                    usage=usage.strip())
    create_options(oparser)
    (opts, cmd, args) = parse_options(oparser, sys.argv[1:])

    try:
        start_time = time.time()
        result = cmd(opts, args)
        end_time = time.time()
        logging.debug("Completed in %-0.4f sec." % (end_time - start_time))
        sys.exit(result)
    except (RuntimeError,
            NotImplementedError), ex:
        oparser.print_usage()
        logging.error("ERROR: %s" % ex)
        sys.exit(1)


if __name__ == '__main__':
    main()
