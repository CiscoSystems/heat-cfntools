#!/usr/bin/env python
# vim: tabstop=4 shiftwidth=4 softtabstop=4
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.

"""
Tools to generate JEOS TDLs, build the images and register them in Glance.
"""

import base64
import ConfigParser
import gettext
import inspect
import json
import logging
from lxml import etree
import optparse
import os
import os.path
import re
import sys
import textwrap
import time


from glance.common import exception
from glance import client as glance_client
import oz.TDL
import oz.GuestFactory


possible_topdir = os.path.normpath(os.path.join(os.path.abspath(sys.argv[0]),
                                   os.pardir,
                                   os.pardir))

if os.path.exists(os.path.join(possible_topdir, 'heat_jeos')):
    sys.path.insert(0, possible_topdir)

import heat_jeos
jeos_module_path = os.path.abspath(os.path.dirname(heat_jeos.__file__))


def command_tdl(options, arguments):
    '''
    Create a new TDL.

    Usage:
    heat-jeos tdl <distribution> <architecture> <image type> <output tdl>
    '''
    try:
        distro, arch, instance_type, output_tdl = arguments
    except ValueError:
        print inspect.getdoc(command_tdl)
        sys.exit(1)
    create_tdl(distro, arch, instance_type, options.images_dir,
               options.jeos_dir, options.cfn_dir, output_tdl)

def command_image(options, arguments):
    '''
    Create a new JEOS image.

    Usage:
    heat-jeos image <distribution> <architecture> <image type> <tdl>
    '''
    if os.geteuid() != 0:
        logging.error("This command must be run as root")
        sys.exit(1)
    try:
        distro, arch, instance_type, input_tdl = arguments
    except ValueError:
        print inspect.getdoc(command_image)
        sys.exit(1)

    if not os.access(input_tdl, os.R_OK):
        logging.error('The tdl for that disto/arch is not available')
        sys.exit(1)

    dsk_path, qcow2_path, image_name = target_image_paths(options,
            distro, arch, instance_type)

    if os.access(qcow2_path, os.R_OK):
        rebuild = options.yes or prompt_bool('An existing JEOS was found '
                'on disk. Do you want to build a fresh JEOS? (y/n) ')
        if not rebuild:
            logging.info('No action taken')
            return False

    logging.info('Creating JEOS image (%s) - '
                 'this takes approximately 10 minutes.' % image_name)
    build_jeos(input_tdl, dsk_path, qcow2_path)
    return True


def command_register(options, arguments):
    '''
    Register the previously generated image with Glance.

    Usage:
    heat-jeos register <distribution> <architecture> <image type>
    '''
    try:
        distro, arch, instance_type = arguments
    except ValueError:
        print inspect.getdoc(command_register)
        sys.exit(1)

    dsk_path, qcow2_path, image_name = target_image_paths(options,
            distro, arch, instance_type)

    logging.info('Registering JEOS image (%s) with OpenStack Glance.' %
                 image_name)
    creds = dict(username=options.username,
                 password=options.password,
                 tenant=options.tenant,
                 auth_url=options.auth_url,
                 strategy=options.auth_strategy)

    # When neither host nor port are specified and we're using Keystone auth,
    # let it tell us the Glance entrypoint
    configure_via_auth = (options.auth_strategy == 'keystone' and
                          not (options.glance_host or options.glance_port))

    # NOTE: these are ignored by the client when `configure_via_auth` is True
    glance_host = options.glance_host if options.glance_host else '0.0.0.0'
    try:
        glance_port = int(options.glance_port) if options.glance_port else 9292
    except:
        logging.error('Port must be a number.')
        sys.exit(1)

    if configure_via_auth:
        logging.debug('Using Glance entry point received by Keystone.')
    else:
        logging.debug('Connecting to Glance at host: %s, port: %d' %
                      (glance_host, glance_port))

    client = glance_client.Client(host=glance_host,
                                  port=glance_port,
                                  use_ssl=False,
                                  auth_tok=None,
                                  configure_via_auth=configure_via_auth,
                                  creds=creds)

    parameters = {
        "filters": {},
        "limit": 10,
    }

    try:
        images = client.get_images(**parameters)
    except exception.ClientConnectionError, e:
        logging.error('Failed to connect to the Glance API server.')
        sys.exit(1)

    try:
        image = [i for i in images if i['name'] == image_name][0]
    except IndexError:
        image = None

    if image:
        delete_image = options.yes or prompt_bool('Do you want to '
                'delete the existing JEOS in glance? (y/n) ')
        if delete_image:
            client.delete_image(image['id'])
        else:
            logging.info('No action taken')
            sys.exit(0)

    register_image(client, qcow2_path, image_name, options.username, image)

def command_all(options, arguments):
    '''
    Create a new JEOS (Just Enough Operating System) image and register it.

    Usage:
    heat-jeos create <distribution> <architecture> <image type>

    Distribution: Distribution such as 'F16', 'F17', 'U10', 'D6'.
    Architecture: Architecture such as 'i386' 'i686' or 'x86_64'.
    Image Type: Image type such as 'gold' or 'cfntools'.
                'gold' is a basic gold JEOS.
                'cfntools' contains the cfntools helper scripts.

    The command must be run as root in order for libvirt to have permissions
    to create virtual machines and read the raw DVDs.
    '''
    if os.geteuid() != 0:
        logging.error("This command must be run as root")
        sys.exit(1)
    try:
        distro, arch, instance_type = arguments
    except ValueError:
        print inspect.getdoc(command_all)
        sys.exit(1)

    temporary_tdl_path = '/tmp/tdl'
    command_tdl(options, [distro, arch, instance_type, temporary_tdl_path])

    dsk_path, qcow2_path, image_name = target_image_paths(options,
            distro, arch, instance_type)

    built = command_image(options,
                          [distro, arch, instance_type, temporary_tdl_path])
    if built:
        command_register(options, [distro, arch, instance_type])
    elif os.access(qcow2_path, os.R_OK):
        register = options.yes or prompt_bool('Do you want to '
                'register your existing JEOS file with glance? (y/n) ')

        if register:
            command_register(options, arguments)
        else:
            logging.info('No action taken')
            sys.exit(0)


def target_image_paths(options, distro, arch, instance_type):
    arches = ('x86_64', 'i386', 'amd64')
    arches_str = " | ".join(arches)
    instance_types = ('gold', 'cfntools')
    instances_str = " | ".join(instance_types)

    if not arch in arches:
        logging.error('arch %s not supported' % arch)
        logging.error('try: heat jeos-create %s [ %s ]' % (distro, arches_str))
        sys.exit(1)

    if not instance_type in instance_types:
        logging.error('A JEOS instance type of %s not supported' %
            instance_type)
        logging.error('try: heat jeos-create %s %s [ %s ]' %
            (distro, arch, instances_str))
        sys.exit(1)

    src_arch = 'i386'
    fedora_match = re.match('F(1[6-7])', distro)
    if fedora_match:
        if arch == 'x86_64':
            src_arch = 'x86_64'
        version = fedora_match.group(1)
        iso = '%s/Fedora-%s-%s-DVD.iso' % (options.images_dir, version, arch)
    elif distro == 'U10':
        if arch == 'amd64':
            src_arch = 'x86_64'
        iso = '%s/ubuntu-10.04.3-server-%s.iso' % (options.images_dir, arch)
    else:
        logging.error('distro %s not supported' % distro)
        logging.error('try: F16, F17 or U10')
        sys.exit(1)

    if not os.access(iso, os.R_OK):
        logging.error('*** %s does not exist.' % (iso))
        sys.exit(1)

    dsk_filename = '%s/%s-%s-%s-jeos.dsk' % (options.images_dir, distro,
                                             src_arch, instance_type)
    qcow2_filename = '%s/%s-%s-%s-jeos.qcow2' % (options.images_dir, distro,
                                                 arch, instance_type)
    image_name = '%s-%s-%s' % (distro, arch, instance_type)

    return dsk_filename, qcow2_filename, image_name



def prompt_bool(question):
    while True:
        answer = raw_input(question).lower()
        if answer in ('y', 'yes'):
            return True
        if answer in ('n', 'no'):
            return False

def create_tdl(distro, arch, instance_type, images_dir, jeos_dir, cfn_dir,
               output_tdl_path):
    tdl_file = '%s-%s-%s-jeos.tdl' % (distro, arch, instance_type)
    tdl_path = os.path.join(jeos_dir, tdl_file)
    logging.debug("Using tdl: %s" % tdl_path)

    # Load the cfntools into the cfntool image by encoding them in base64
    # and injecting them into the TDL at the appropriate place
    if instance_type == 'cfntools':
        tdl_xml = etree.parse(tdl_path)
        cfn_tools = ['cfn-init', 'cfn-hup', 'cfn-signal',
                    'cfn-get-metadata', 'cfn_helper.py', 'cfn-push-stats']
        for cfnname in cfn_tools:
            f = open('%s/%s' % (cfn_dir, cfnname), 'r')
            cfscript_e64 = base64.b64encode(f.read())
            f.close()
            cfnpath = "/template/files/file[@name='/opt/aws/bin/%s']" % cfnname
            tdl_xml.xpath(cfnpath)[0].text = cfscript_e64

        # TODO(sdake) INSECURE
        tdl_xml.write(output_tdl_path, xml_declaration=True)


def build_jeos(tdl_path, dsk_path, qcow2_path):
    if os.path.exists(qcow2_path):
        os.remove(qcow2_path)
    if os.path.exists(dsk_path):
        os.remove(dsk_path)

    logging.debug("Running Oz")
    tdl = oz.TDL.TDL(open(tdl_path, 'r').read())
    config_file = "/etc/oz/oz.cfg"
    config = ConfigParser.SafeConfigParser()
    if os.access(config_file, os.F_OK):
        config.read(config_file)

    guest = oz.GuestFactory.guest_factory(tdl, config, None, None)
    guest.check_for_guest_conflict()

    force_download = False
    try:
        guest.generate_install_media(force_download)
        try:
            guest.generate_diskimage(force=force_download)
            libvirt_xml = guest.install(50000, force_download)
        except:
            guest.cleanup_old_guest()
            raise
    finally:
        guest.cleanup_install()

    guest.customize(libvirt_xml)

    if not os.access(dsk_path, os.R_OK):
        logging.error('oz-install did not create the image,'
                      ' check your oz installation.')
        sys.exit(1)

    logging.info('Converting raw disk image to a qcow2 image.')
    os.system("qemu-img convert -c -O qcow2 %s %s" % (dsk_path, qcow2_path))


def register_image(client, qcow2_path, name, owner, existing_image):
    image_meta = {'name': name,
                  'is_public': True,
                  'disk_format': 'qcow2',
                  'min_disk': 0,
                  'min_ram': 0,
                  'owner': owner,
                  'container_format': 'bare'}

    try:
        if existing_image:
            client.delete_image(existing_image['id'])

        with open(qcow2_path) as ifile:
            image_meta = client.add_image(image_meta, ifile)
        image_id = image_meta['id']
        logging.debug(" Added new image with ID: %s" % image_id)
        logging.debug(" Returned the following metadata for the new image:")
        for k, v in sorted(image_meta.items()):
            logging.debug(" %(k)30s => %(v)s" % locals())
    except exception.ClientConnectionError, e:
        logging.error((" Failed to connect to the Glance API server." +\
               " Is the server running?" % locals()))
        pieces = unicode(e).split('\n')
        for piece in pieces:
            logging.error(piece)
            sys.exit(1)
    except Exception, e:
        logging.error(" Failed to add image. Got error:")
        pieces = unicode(e).split('\n')
        for piece in pieces:
            logging.error(piece)
        logging.warning(" Note: Your image metadata may still be in the " +\
               "registry, but the image's status will likely be 'killed'.")



def create_options(parser):
    """
    Sets up the CLI and config-file options that may be
    parsed and program commands.

    :param parser: The option parser
    """
    parser.add_option('-j', '--jeos-dir',
                      default=os.path.join(jeos_module_path, 'jeos'),
                      help="Path to the JEOS templates directory")
    parser.add_option('-c', '--cfn-dir',
                      default=os.path.join(jeos_module_path, 'cfntools'),
                      help="Path to cfntools directory")
    parser.add_option('-i', '--images-dir',
                      default='/var/lib/libvirt/images',
                      help="Path to the base OS images directory")
    parser.add_option('-v', '--verbose', default=False, action="store_true",
                      help="Print more verbose output")
    parser.add_option('-d', '--debug', default=False, action="store_true",
                      help="Print more verbose output")
    parser.add_option('-y', '--yes', default=False, action="store_true",
                      help="Don't prompt for user input; assume the answer to "
                           "every question is 'yes'.")
    parser.add_option('-H', '--glance-host',
                      default=None,
                      help="Glance hostname")
    parser.add_option('-P', '--glance-port',
                      default=None,
                      help="Glance port number")
    parser.add_option('-A', '--auth_token', dest="auth_token",
                      metavar="TOKEN", default=None,
                      help="Authentication token to use to identify the "
                           "client to the heat server")
    parser.add_option('-I', '--username', dest="username",
                      metavar="USER", default=None,
                      help="User name used to acquire an authentication token")
    parser.add_option('-K', '--password', dest="password",
                      metavar="PASSWORD", default=None,
                      help="Password used to acquire an authentication token")
    parser.add_option('-T', '--tenant', dest="tenant",
                      metavar="TENANT", default=None,
                      help="Tenant name used for Keystone authentication")
    parser.add_option('-R', '--region', dest="region",
                      metavar="REGION", default=None,
                      help="Region name. When using keystone authentication "
                      "version 2.0 or later this identifies the region "
                      "name to use when selecting the service endpoint. A "
                      "region name must be provided if more than one "
                      "region endpoint is available")
    parser.add_option('-N', '--auth_url', dest="auth_url",
                      metavar="AUTH_URL", default=None,
                      help="Authentication URL")
    parser.add_option('-S', '--auth_strategy', dest="auth_strategy",
                      metavar="STRATEGY", default=None,
                      help="Authentication strategy (keystone or noauth)")


def credentials_from_env():
    return dict(username=os.getenv('OS_USERNAME'),
                password=os.getenv('OS_PASSWORD'),
                tenant=os.getenv('OS_TENANT_NAME'),
                auth_url=os.getenv('OS_AUTH_URL'),
                auth_strategy=os.getenv('OS_AUTH_STRATEGY'))


def parse_options(parser, cli_args):
    """
    Returns the parsed CLI options, command to run and its arguments, merged
    with any same-named options found in a configuration file

    :param parser: The option parser
    """
    if not cli_args:
        cli_args.append('-h')  # Show options in usage output...

    (options, args) = parser.parse_args(cli_args)
    env_opts = credentials_from_env()
    for option, env_val in env_opts.items():
        if not getattr(options, option):
            setattr(options, option, env_val)

    if not options.auth_strategy:
        options.auth_strategy = 'noauth'

    # HACK(sirp): Make the parser available to the print_help method
    # print_help is a command, so it only accepts (options, args); we could
    # one-off have it take (parser, options, args), however, for now, I think
    # this little hack will suffice
    options.__parser = parser

    if not args:
        parser.print_usage()
        sys.exit(0)

    command_name = args.pop(0)
    command = lookup_command(parser, command_name)

    if options.debug:
        logging.basicConfig(format='%(levelname)s:%(message)s',\
            level=logging.DEBUG)
        logging.debug("Debug level logging enabled")
    elif options.verbose:
        logging.basicConfig(format='%(levelname)s:%(message)s',\
            level=logging.INFO)
    else:
        logging.basicConfig(format='%(levelname)s:%(message)s',\
            level=logging.WARNING)

    options.jeos_dir = os.path.join(os.getcwd(), options.jeos_dir)
    options.cfn_dir = os.path.join(os.getcwd(), options.cfn_dir)

    return (options, command, args)


def print_help(options, args):
    """
    Print help specific to a command
    """
    parser = options.__parser

    if not args:
        parser.print_usage()

    subst = {'prog': os.path.basename(sys.argv[0])}
    docs = [lookup_command(parser, cmd).__doc__ % subst for cmd in args]
    print '\n\n'.join(docs)


def lookup_command(parser, command_name):
    commands = {
        'create': command_all,
        'tdl': command_tdl,
        'image': command_image,
        'register': command_register,
        'help': print_help,
    }

    try:
        command = commands[command_name]
    except KeyError:
        parser.print_usage()
        sys.exit("Unknown command: %s" % command_name)

    return command


def main():
    '''
    '''
    usage = """
%prog <command> [options] [args]

Commands:

    create     Create a JEOS image and register it with OpenStack

    tdl        Prepare a template ready for Oz

    image      Build an image from the specified template

    register   Register the built image with OpenStack Glance

    help <command>  Output help for one of the commands below

"""

    oparser = optparse.OptionParser(version='%%prog %s'
                                    % '0.0.1',
                                    usage=usage.strip())
    create_options(oparser)
    (opts, cmd, args) = parse_options(oparser, sys.argv[1:])

    try:
        start_time = time.time()
        result = cmd(opts, args)
        end_time = time.time()
        logging.debug("Completed in %-0.4f sec." % (end_time - start_time))
        sys.exit(result)
    except (RuntimeError,
            NotImplementedError), ex:
        oparser.print_usage()
        logging.error("ERROR: " % ex)
        sys.exit(1)


if __name__ == '__main__':
    main()
